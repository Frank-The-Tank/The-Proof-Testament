[[[

5.6a)



Let H represent "I will eat my hat."

The formalization of B's reply is b ⇒ H.

So we take as true the expression b ≡ (b ⇒ H).

]]]

Proof:

 b ≡ (b ⇒ H)

=  〈 (3.60) Implication 〉

 b ≡ b ⋀ H ≡ b

=  〈 Symmetry of ≡ 〉

 b ≡ b ≡ b ⋀ H

=  〈 (3.3) Identity of ≡, twice 〉

 b ⋀ H



[[[

Hence B is a knight and must eat his hat.

]]]



------------------------------



[[[

5.6b)



The formalization of B's statement is c ⇒ ¬b.

So we take as true the expression b ≡ c ⇒ ¬b.

]]]

Proof:

 b ≡ c ⇒ ¬b

=  〈 (3.57) Implication 〉

 b ≡ c ⋁ ¬b ≡ ¬b

=  〈 Symmetry of ≡ 〉

 b ≡ ¬b ≡ c ⋁ ¬b

=  〈 (3.15) 〉

 false ≡ c ⋁ ¬b

=  〈 (3.15) 〉

 ¬(c ⋁ ¬b)

=  〈 De Morgan 〉

 ¬c ⋀ ¬¬b

=  〈 Double negation 〉

 ¬c ⋀ b



[[[

Hence B is a knight and C is a knave.

]]]



------------------------------



[[[

5.6c)



Let G represent "Gold is on the island."

The formalization of B's statement is G ≡ b.

So we take as true the expression b ≡ G ≡ b.

]]]

Proof:

 b ≡ G ≡ b

=  〈 Symmetry of ≡ 〉

 b ≡ b ≡ G

=  〈 Identity of ≡, twice 〉

 G



[[[

Hence there is gold on the island. However, it cannot be determined whether B

is a knight or a knave.

]]]



------------------------------



[[[

8.1a)



]]]

     Proof:

e(a.u, w)



[[[

The function call is type correct.

]]]



------------------------------



[[[

8.1b)



]]]

          Proof:

b.x



[[[

Incorrect: b takes a parameter of type B, but x is type C.

]]]



------------------------------



[[[

8.1c)



]]]

          Proof:

e(a(c.x), a.u)



[[[

The function call is type correct.

]]]



------------------------------



[[[

8.1d)



]]]

          Proof:

a(c(b(a.y)))



[[[

Incorrect: a takes a parameter of type A, but y is of type D.

]]]



------------------------------



[[[

8.1e)

Proof:

]]]

          Proof:

d(c.x, c.x)



[[[

Incorrect: The second parameter of d must be type C, but c returns type A.

]]]
